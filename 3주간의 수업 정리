
문제가 주어지고 프로그램을 작성하라고 할때

 객체지향적으로 생각하자.!!
 class = 
 		  데이타를 기억할 공간으로  member변수
 		 member변수를 조작 처리 할 로직을 가지고 있는 메소드()가 필요하다.
 		 inner =>~~~~Listener가 가지고 있는 메소드를 재정의 해봤다.
         ====> 멤버
  
  class안에 있는 멤버에 접근 하는 방법
  ==> 멤버의 정의에 따라 다르다.
  	  (클래스멤버)static ==> 클래스명.static한 멤버 
  	  (인스턴스멤버)static 구문없이  ==> 클래스의 인스턴스.static이 붙어 있지 않은 멤버
 
  class AA{
  public static int age;
  public String name;
 }
 
 class BB{
  public void m() {
 	 int x = AA.age;
 	 AA ref = new AA();
  	String ss =  ref.name;
  } 
 }
 //////////////////////////
 	접근유형
 	private
 	default(package=페케이지 안에서만 퍼블릭하니까 페케이지라고도 부름) 
 	protected
 	public
 	
   ////////////////////////
   oop = 은닉성
   		  class~~{}
   		  private,protected
   ,	 
   		추상성(건물 설계에 인테리어 배치가 들어가진 않는 것.),
		 객체 한 가지에 대한 설계다.
		 설계도면과 같은 것.    		
		 데이타 어떤 걸로 할 것? ==> 속성이 나타나도록
		    		
   		상속성,
   		extends, implements
   		상속할 수 있는 대상??( 전부!!!,단 private적인 것은 메모리 상에는 잡히지만,
  						자식 클래스에서 직접 접근이 안되서 상속이 안된다고 표현한다. )
  				private 메소드는 override가 될까요?
  				안된다. 범위가 작음.
  				
   		
   		 다형성 ==>멤버메소드   에 대한 것
   		 		
 			을 만들기 위해서overloding (과) varargs v m1(int ...a)
 												varargs	- 동일한 자료형의 갯수로 오버로딩할것을
 															줄이려고 
 			override을 이용해서 다형성을 구형한다.
 			
 	
 		class CC{
 		 void   m()
 		}
 		
 	★override의 주의점★
 		
 		1.메소드명 동일
 		
 		2.매개변수 타입,갯수
 		
 		3.리턴자료형
 		
 		4.접근유형(기초클래스가 가지고 있는 접근 유형보다 관대해야 한다.)
 		public  ==> public
 		protected ==> protected,public
 		
 		5.예외에서 
 		throws
 		 떠넘길때 사용
 		기초:method() throws ~~~Exception{} => 입샙션이 발생할거야~~ 
 		서브:method() throws ~~~Exception{}
 			method() {}
			method() throws ~~~의 서브 Exception{}
 		try~catch절
 		 처리할때 사용
 		 catch(~~~Exception e){}
 		 catch(~~~Exception e){}
 		 catch(위  catch절 보다 기초Exception e){}//위  catch절 보다 기초Exception이 와야한다.
 			
  